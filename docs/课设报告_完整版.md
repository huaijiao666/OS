# 操作系统课程设计报告

## 文件系统模拟器

---

# 1 前言

## 1.1 选择的题目要求

本次课程设计的任务是在现有操作系统基础上，模拟实现部分操作系统的功能和相关算法。具体要求包括：

1. **磁盘与文件组织**：建立M×N大小的模拟磁盘（M=64B，N=1024），采用位图+混合索引方式组织数据
2. **文件接口**：实现文件的创建、查询、查看、修改、删除等操作
3. **内存缓冲页**：实现M×K大小的缓冲区（K=16），支持LRU页面置换
4. **进程同步与互斥**：采用共享内存通信和条件变量同步机制
5. **可视化**：对内存缓冲、磁盘信息、目录信息进行可视化显示

## 1.2 设计的目的

- 深入理解操作系统文件系统的组织结构和管理机制
- 掌握磁盘空间管理的位图法和索引分配方式
- 理解内存缓冲区管理和页面置换算法
- 掌握进程间通信和同步机制
- 培养系统软件的设计和开发能力

## 1.3 设计的意义

通过模拟实现文件系统，能够将操作系统课程中的理论知识与实践相结合，加深对文件系统、内存管理、进程调度等核心概念的理解。

## 1.4 实现方案选择

| 模块 | 选择的实现方式 |
|------|---------------|
| 数据组织 | 混合索引方式 |
| 空闲块管理 | 位示图法 |
| 文件访问方式 | 非阻塞I/O |
| 进程通信 | 共享内存 |
| 同步机制 | 条件变量 |
| 调度策略 | 时间片轮转(RR) |
| 页面置换 | LRU算法 |

---

# 2 需求分析

## 2.1 设计任务

设计并实现一个文件系统模拟器，包含以下功能模块：

1. 虚拟磁盘模块：模拟物理磁盘的读写操作
2. 文件系统模块：实现文件和目录的管理
3. 缓冲区模块：实现内存缓冲页的管理
4. 进程管理模块：实现进程的创建和调度
5. 调度器模块：实现时间片轮转调度算法
6. IPC模块：实现共享内存通信
7. 可视化界面：提供Web界面展示系统状态

## 2.2 功能模块图

【图2-1 系统功能模块图】

```
需要生成的图片说明：
- 图片类型：系统功能模块层次图
- 内容：顶层为"文件系统模拟器"，下分7个子模块
  - 虚拟磁盘模块
  - 文件系统模块  
  - 缓冲区模块
  - 进程管理模块
  - 调度器模块
  - IPC模块
  - Web可视化模块
- 风格：白色背景，蓝色方框，黑色连线
- AI绘图Prompt: "System architecture diagram, white background, blue rectangular boxes connected by black lines, top box labeled 'File System Simulator', 7 child boxes below: Virtual Disk, File System, Buffer Manager, Process Manager, Scheduler, IPC Module, Web Visualization, clean professional style, no shadows"
```

## 2.3 系统流程图

【图2-2 系统主流程图】

```
需要生成的图片说明：
- 图片类型：程序流程图
- 内容：
  开始 → 初始化磁盘 → 加载文件系统 → 启动调度器 → 等待用户命令 
  → 解析命令 → 创建进程 → 加入就绪队列 → 调度执行 → 返回结果 → 等待用户命令（循环）
- 风格：白色背景，标准流程图符号（椭圆、矩形、菱形）
- AI绘图Prompt: "Flowchart diagram, white background, standard flowchart symbols, start/end ovals, process rectangles, decision diamonds, black arrows, labels: Start, Initialize Disk, Load FileSystem, Start Scheduler, Wait Command, Parse Command, Create Process, Add to Queue, Schedule Execute, Return Result, loop back arrow, clean professional style"
```

## 2.4 输入输出规范

### 2.4.1 正确输入及输出

| 命令 | 输入示例 | 正确输出 |
|------|----------|----------|
| 创建文件 | `touch test.txt` | 文件创建成功 |
| 写入内容 | `echo Hello > test.txt` | (无输出，成功) |
| 查看文件 | `cat test.txt` | Hello |
| 查看信息 | `stat test.txt` | 文件详细信息 |
| 删除文件 | `rm test.txt` | (无输出，成功) |
| 磁盘状态 | `df` | 磁盘使用表 |
| 缓冲状态 | `free` | 缓冲区状态 |
| 进程列表 | `ps` | 进程列表 |
| 调度状态 | `top` | 调度器状态 |

### 2.4.2 错误输入及输出

| 错误输入 | 输出 |
|----------|------|
| `cat notexist.txt` | 文件 notexist.txt 不存在 |
| `rm openedfile.txt`（已打开）| 文件正在被使用，无法删除 |
| `cd notexist` | 目录 notexist 不存在 |
| `mkdir existdir`（已存在）| 目录 existdir 已存在 |

## 2.5 组内分工说明

（请根据实际情况填写）

| 成员 | 负责模块 |
|------|----------|
| 成员1 | 虚拟磁盘、文件系统模块 |
| 成员2 | 缓冲区管理、进程调度模块 |
| 成员3 | IPC通信、Web可视化界面 |

---

# 3 系统设计

## 3.1 数据结构定义

### 3.1.1 磁盘布局

```
磁盘总大小: 64KB (64B × 1024块)

┌──────────┬──────────┬──────────────┬─────────────────────┐
│  超级块   │  位图区   │    iNode区    │       数据区         │
│  (1块)   │  (2块)   │   (32块)     │     (989块)         │
│  块 0    │ 块 1-2   │  块 3-34     │    块 35-1023       │
└──────────┴──────────┴──────────────┴─────────────────────┘
```

### 3.1.2 iNode结构（64字节）

```python
class INode:
    inode_id: int          # 2字节 - iNode编号
    file_type: int         # 1字节 - 文件类型(0空闲/1目录/2普通文件)
    permissions: int       # 1字节 - 权限(rwx)
    size: int              # 4字节 - 文件大小
    create_time: int       # 8字节 - 创建时间
    modify_time: int       # 8字节 - 修改时间
    link_count: int        # 2字节 - 链接计数
    direct_blocks: [int]   # 12字节 - 6个直接索引块
    single_indirect: int   # 2字节 - 一级间接索引
    double_indirect: int   # 2字节 - 二级间接索引
    # 保留22字节
```

【图3-1 iNode结构示意图】

```
需要生成的图片说明：
- 图片类型：数据结构布局图
- 内容：64字节的iNode结构，按偏移量划分字段
  偏移0-1: iNode ID
  偏移2: 文件类型
  偏移3: 权限
  偏移4-7: 文件大小
  偏移8-15: 创建时间
  偏移16-23: 修改时间
  偏移24-25: 链接计数
  偏移26-37: 直接索引块(6个)
  偏移38-39: 一级间接索引
  偏移40-41: 二级间接索引
  偏移42-63: 保留
- 风格：白色背景，表格形式，带偏移量标注
- AI绘图Prompt: "Data structure layout diagram, white background, horizontal bar divided into sections with byte offsets labeled, sections: iNode ID(0-1), Type(2), Perm(3), Size(4-7), CTime(8-15), MTime(16-23), Links(24-25), Direct Blocks(26-37), Indirect(38-39), Double Indirect(40-41), Reserved(42-63), clean professional style, labeled bytes"
```

### 3.1.3 目录项结构（26字节）

```python
class DirectoryEntry:
    name: str      # 24字节 - 文件名(UTF-8)
    inode_id: int  # 2字节 - iNode号
```

### 3.1.4 混合索引结构

【图3-2 混合索引结构图】

```
需要生成的图片说明：
- 图片类型：索引结构示意图
- 内容：
  iNode框 → 6个直接索引指向数据块
         → 一级间接索引 → 间接块 → 32个数据块
         → 二级间接索引 → 一级间接块 → 二级间接块 → 32×32个数据块
- 风格：白色背景，箭头连接的框图
- AI绘图Prompt: "File system hybrid indexing diagram, white background, left box labeled iNode with arrows pointing to: 6 direct data blocks, single indirect block pointing to 32 data blocks, double indirect block pointing to intermediate blocks then to data blocks, clean lines, professional style, labeled arrows"
```

### 3.1.5 缓冲页结构

```python
class BufferPage:
    page_id: int           # 缓冲页ID
    block_id: int          # 对应磁盘块号
    owner_process: int     # 所有者进程ID
    data: bytearray        # 页面数据(64字节)
    state: PageState       # FREE/CLEAN/DIRTY
    access_time: float     # 最后访问时间
    is_pinned: bool        # 是否钉住
```

### 3.1.6 进程控制块

```python
class Process:
    pid: int               # 进程ID
    name: str              # 进程名称
    state: ProcessState    # NEW/READY/RUNNING/BLOCKED/TERMINATED
    command: CommandType   # 命令类型
    time_slice: int        # 分配的时间片
    remaining_time: int    # 剩余时间片
    cpu_time: float        # CPU使用时间
```

## 3.2 主要函数定义

### 3.2.1 虚拟磁盘模块 (disk.py)

| 函数名 | 功能 | 参数 | 返回值 |
|--------|------|------|--------|
| `read_block(block_id)` | 读取磁盘块 | 块号 | bytes |
| `write_block(block_id, data)` | 写入磁盘块 | 块号, 数据 | None |
| `allocate_block()` | 分配空闲块 | 无 | 块号 |
| `free_block(block_id)` | 释放块 | 块号 | None |
| `get_bitmap_status()` | 获取位图 | 无 | list |

### 3.2.2 文件系统模块 (filesystem.py)

| 函数名 | 功能 |
|--------|------|
| `create_file(filename, content)` | 创建文件 |
| `read_file(filename, block_index)` | 读取文件 |
| `write_file(filename, content)` | 写入文件 |
| `delete_file(filename)` | 删除文件 |
| `list_directory()` | 列出目录 |
| `create_directory(dirname)` | 创建目录 |
| `change_directory(dirname)` | 切换目录 |
| `open_file(filename, pid, mode)` | 打开文件 |
| `close_file(filename, pid)` | 关闭文件 |

### 3.2.3 缓冲区模块 (buffer.py)

| 函数名 | 功能 |
|--------|------|
| `get_page(block_id, process_id)` | 获取缓冲页 |
| `read_page(block_id, process_id)` | 读取页面 |
| `write_page(block_id, data, process_id)` | 写入页面 |
| `flush_all()` | 刷新所有脏页 |
| `_find_victim_lru()` | LRU选择牺牲页 |

### 3.2.4 进程管理模块 (process.py)

| 函数名 | 功能 |
|--------|------|
| `create_process(name, command, args)` | 创建进程 |
| `execute_process(pid)` | 执行进程 |
| `terminate_process(pid)` | 终止进程 |
| `block_process(pid)` | 阻塞进程 |
| `unblock_process(pid)` | 解除阻塞 |

### 3.2.5 调度器模块 (scheduler.py)

| 函数名 | 功能 |
|--------|------|
| `start()` | 启动调度器 |
| `stop()` | 停止调度器 |
| `add_process(pid)` | 添加到就绪队列 |
| `_scheduler_loop()` | 调度主循环 |
| `_run_time_slice()` | 执行时间片 |

## 3.3 函数调用关系图

【图3-3 函数调用关系图】

```
需要生成的图片说明：
- 图片类型：函数调用层次图
- 内容：
  app.py (顶层)
    ├── FileSystem
    │   ├── VirtualDisk
    │   │   └── read_block, write_block, allocate_block
    │   └── create_file, read_file, delete_file
    ├── BufferManager
    │   ├── get_page
    │   ├── read_page, write_page
    │   └── _find_victim_lru
    ├── ProcessManager
    │   ├── create_process
    │   └── execute_process
    ├── RRScheduler
    │   ├── start, stop
    │   └── _scheduler_loop
    └── SharedMemoryManager
        ├── create, destroy
        └── read, write
- 风格：白色背景，树形结构
- AI绘图Prompt: "Function call hierarchy diagram, white background, tree structure starting from app.py at top, branches to FileSystem, BufferManager, ProcessManager, RRScheduler, SharedMemoryManager, each with sub-functions listed below, black lines connecting nodes, clean professional style"
```

## 3.4 主程序伪码

```
程序 文件系统模拟器:
    初始化:
        disk = 创建虚拟磁盘()
        filesystem = 创建文件系统(disk)
        buffer_manager = 创建缓冲管理器(disk)
        process_manager = 创建进程管理器()
        scheduler = 创建RR调度器(process_manager)
        shm_manager = 创建共享内存管理器()
        
        设置进度回调函数()
        启动调度器()
        启动WebSocket广播器()
    
    主循环:
        等待HTTP请求或WebSocket消息
        
        如果是文件操作请求:
            创建进程(命令类型, 参数)
            添加进程到就绪队列()
            执行进程()
            返回结果给客户端
            
        如果是系统状态请求:
            获取磁盘/缓冲区/进程状态
            返回JSON响应
            
        如果是调度器控制请求:
            执行启动/停止/暂停/恢复操作
            返回操作结果
```

---

# 4 系统实现

## 4.1 虚拟磁盘实现

### 4.1.1 磁盘初始化

```python
def _format_disk(self):
    """格式化磁盘"""
    # 创建空磁盘文件
    with open(self.disk_path, 'wb') as f:
        f.write(b'\x00' * DISK_SIZE)
    
    # 初始化超级块
    self._write_superblock()
    
    # 初始化位图（标记元数据区已使用）
    self._init_bitmap()
    
    # 初始化iNode区
    self._init_inodes()
```

### 4.1.2 位图管理

```python
def allocate_block(self) -> Optional[int]:
    """分配空闲块（位图法）"""
    with self.lock:
        for i in range(DATA_START_BLOCK, BLOCK_COUNT):
            if not self._get_bit(i):
                self._set_bit(i, True)
                self.free_blocks -= 1
                self._save_bitmap()
                return i
        return None
```

## 4.2 文件系统实现

### 4.2.1 创建文件

```python
def create_file(self, filename: str, content: bytes) -> Dict:
    with self.lock:
        # 1. 验证文件名
        # 2. 检查是否已存在
        # 3. 分配iNode
        # 4. 分配数据块
        # 5. 写入数据（带延时用于可视化）
        for i, block_id in enumerate(blocks):
            notify_progress('write', filename, i+1, len(blocks), block_id)
            self.disk.write_block(block_id, block_data)
            time.sleep(IO_DELAY)  # 可视化延时
        # 6. 添加目录项
```

### 4.2.2 非阻塞I/O实现

```python
def open_file(self, filename: str, process_id: int, mode: str) -> Dict:
    """非阻塞I/O方式打开文件"""
    with self.lock:
        if inode_id in self.open_files:
            existing = self.open_files[inode_id]
            if 'w' in existing['mode'] or 'w' in mode:
                return {
                    'success': False,
                    'would_block': True  # 非阻塞标志：立即返回而不等待
                }
        
        self.open_files[inode_id] = {
            'process_id': process_id,
            'mode': mode
        }
```

## 4.3 缓冲区实现

### 4.3.1 LRU页面置换

```python
def _find_victim_lru(self) -> Optional[int]:
    """LRU算法选择牺牲页"""
    victim = None
    oldest_time = float('inf')
    
    for i, page in enumerate(self.pages):
        if page.is_pinned:
            continue
        if page.state != PageState.FREE and page.access_time < oldest_time:
            oldest_time = page.access_time
            victim = i
    
    return victim
```

### 4.3.2 脏页写回

```python
def _writeback_page(self, page_id: int):
    """将脏页写回磁盘"""
    page = self.pages[page_id]
    
    if page.state == PageState.DIRTY:
        self.disk.write_block(page.block_id, bytes(page.data))
        page.state = PageState.CLEAN
        time.sleep(PAGE_SWAP_DELAY)  # 可视化延时
```

## 4.4 进程调度实现

### 4.4.1 时间片轮转调度

```python
def _scheduler_loop(self):
    """RR调度器主循环"""
    while self.state == SchedulerState.RUNNING:
        # 选择下一个进程
        next_pid = self._select_next_process()
        
        if next_pid is None:
            # 空闲等待
            self.condition.wait(timeout=0.1)
            continue
        
        # 调度进程运行
        self._dispatch(next_pid)
        
        # 运行一个时间片
        self._run_time_slice()
```

### 4.4.2 时间片抢占

```python
def _preempt_current(self):
    """时间片用完，抢占当前进程"""
    process = self.process_manager.get_process(self.current_pid)
    
    if process.state == ProcessState.RUNNING:
        process.state = ProcessState.READY
        # 放回队列尾部（RR特性）
        self.ready_queue.append(self.current_pid)
        process.remaining_time = process.time_slice
    
    self.stats['context_switches'] += 1
```

## 4.5 共享内存与条件变量

### 4.5.1 条件变量同步

```python
class SharedMemorySegment:
    def read(self, offset, length, process_id):
        with self.condition:
            # 等待写者完成（条件变量）
            while self.writers > 0:
                self.condition.wait()
            
            self.readers += 1
        
        # 读取数据...
        
        with self.condition:
            self.readers -= 1
            if self.readers == 0:
                self.condition.notify_all()
```

## 4.6 调试中遇到的问题及解决

| 问题 | 原因 | 解决方法 |
|------|------|----------|
| 文件删除后块未释放 | 释放函数未处理间接索引 | 递归释放所有索引块 |
| 多进程访问磁盘冲突 | 缺少同步机制 | 使用RLock可重入锁 |
| 页面置换时数据丢失 | 脏页未写回 | 置换前检查并写回脏页 |
| 调度器死锁 | 条件变量使用不当 | 在锁外执行耗时操作 |

## 4.7 系统存在的问题及改进

| 问题 | 改进方向 |
|------|----------|
| 单用户模式 | 可扩展为多用户支持 |
| 无文件权限检查 | 可增加用户认证和权限验证 |
| 目录不支持树形删除 | 可增加递归删除功能 |
| 缓冲区大小固定 | 可动态调整缓冲区大小 |

---

# 5 用户手册

## 5.1 系统安装

### 5.1.1 环境要求

- Python 3.8+
- Node.js 16+
- 现代浏览器（Chrome/Firefox/Edge）

### 5.1.2 安装步骤

```bash
# 1. 安装后端依赖
cd backend
pip install flask flask-cors flask-socketio

# 2. 安装前端依赖
cd ../frontend
npm install
```

## 5.2 系统启动

```bash
# 终端1：启动后端
cd backend
python app.py

# 终端2：启动前端
cd frontend
npm run dev
```

访问 http://localhost:5173 进入系统

## 5.3 界面说明

【图5-1 系统主界面】
```
需要手动截图说明：
- 截图内容：系统主界面完整截图
- 操作步骤：启动系统后，浏览器访问localhost:5173，截取完整页面
- 标注要点：左侧导航栏、顶部状态栏、主内容区域
```

### 5.3.1 导航栏

| 按钮 | 功能 |
|------|------|
| 仪表盘 | 系统状态总览 |
| 文件 | 文件管理界面 |
| 磁盘 | 磁盘可视化 |
| 缓冲区 | 缓冲页状态 |
| 进程 | 进程列表 |
| 调度器 | 调度器控制 |
| 终端 | 命令行界面 |

## 5.4 命令使用

### 5.4.1 文件操作命令

```bash
# 列出目录
ls

# 创建文件
touch filename.txt

# 写入内容
echo "Hello World" > filename.txt

# 查看内容
cat filename.txt

# 查看文件信息
stat filename.txt

# 删除文件
rm filename.txt

# 创建目录
mkdir dirname

# 切换目录
cd dirname

# 返回上级
cd ..
```

### 5.4.2 磁盘命令

```bash
# 磁盘使用情况
df

# 缓冲区状态
free

# 同步缓冲区
sync

# 格式化磁盘
mkfs --force

# 查看块内容
hexdump 35

# 查看iNode
inode 0

# 文件系统信息
dumpe2fs
```

### 5.4.3 进程命令

```bash
# 进程列表
ps

# 调度状态
top

# 创建后台任务
nice task1 5

# 批量创建任务
batch 3

# 终止进程
kill <pid>
```

### 5.4.4 共享内存命令

```bash
# IPC资源列表
ipcs

# 创建共享内存
shmget 1024

# 写入数据
shmwrite 1 "Hello"

# 读取数据
shmread 1

# 删除共享内存
ipcrm 1
```

---

# 6 测试

## 6.1 文件系统测试

### 6.1.1 文件创建和读取测试

【图6-1 文件创建测试截图】
```
需要手动截图说明：
- 截图内容：终端中执行以下命令的结果
  touch test.txt
  echo "Hello World" > test.txt
  cat test.txt
  stat test.txt
- 标注要点：命令输入和输出结果
```

### 6.1.2 目录操作测试

【图6-2 目录操作测试截图】
```
需要手动截图说明：
- 截图内容：终端中执行以下命令
  mkdir mydir
  cd mydir
  pwd
  touch subfile.txt
  ls
  cd ..
```

## 6.2 磁盘可视化测试

### 6.2.1 位图显示测试

【图6-3 磁盘位图截图】
```
需要手动截图说明：
- 截图内容：磁盘面板的位图显示区域
- 操作步骤：
  1. 点击左侧"磁盘"按钮
  2. 创建几个文件后刷新
  3. 截取位图区域
- 标注要点：超级块、位图区、iNode区、数据区的颜色区分
```

### 6.2.2 iNode查看测试

【图6-4 iNode详情截图】
```
需要手动截图说明：
- 截图内容：点击iNode后显示的详细信息
- 操作步骤：
  1. 在磁盘面板点击"iNode列表"标签
  2. 点击任意iNode
  3. 截取详情区域
```

## 6.3 缓冲区测试

### 6.3.1 缓存命中测试

【图6-5 缓冲区状态截图】
```
需要手动截图说明：
- 截图内容：缓冲区面板
- 操作步骤：
  1. 多次执行 cat 同一文件
  2. 查看缓冲区面板
  3. 截取页面状态和命中率
- 标注要点：命中次数、命中率变化
```

### 6.3.2 页面置换测试

【图6-6 置换日志截图】
```
需要手动截图说明：
- 截图内容：缓冲区面板的置换日志区域
- 操作步骤：读取足够多文件触发置换
```

## 6.4 进程调度测试

### 6.4.1 多进程调度测试

【图6-7 调度器面板截图】
```
需要手动截图说明：
- 截图内容：调度器面板
- 操作步骤：
  1. 执行 batch 3 创建多个任务
  2. 观察就绪队列变化
  3. 截取调度事件日志
```

### 6.4.2 时间片轮转测试

执行 `top` 命令观察调度状态：

```
top - 14:30:25 up 5 min, load average: 45.2%
Tasks: 5 total, 1 running, 3 sleeping
%Cpu(s): 45.2 us, 0.0 sy, 0.0 ni, 54.8 id

Scheduler: RUNNING  Quantum: 100ms  Switches: 12  Preempts: 8
```

## 6.5 共享内存测试

### 6.5.1 共享内存创建和读写

【图6-8 共享内存测试截图】
```
需要手动截图说明：
- 截图内容：终端中执行以下命令
  ipcs
  shmget 1024
  shmwrite 1 "Test Data"
  shmread 1
  ipcs
  ipcrm 1
```

## 6.6 文件保护测试

### 6.6.1 文件锁测试

【图6-9 文件保护测试截图】
```
需要手动截图说明：
- 截图内容：终端中演示文件保护
  touch locked.txt
  open locked.txt
  rm locked.txt  (显示错误：文件正在使用)
  close locked.txt
  rm locked.txt  (成功)
```

---

# 7 结束语

## 7.1 设计成果

本次课程设计成功实现了一个完整的文件系统模拟器，包含以下功能：

1. **完整的文件系统**：支持文件和目录的创建、读取、修改、删除
2. **位图管理**：采用位示图法管理空闲磁盘块
3. **混合索引**：支持直接索引和间接索引，最大文件约66KB
4. **内存缓冲**：16页缓冲区，支持LRU页面置换算法
5. **进程调度**：时间片轮转调度算法，可调节时间片大小
6. **IPC通信**：共享内存通信，条件变量同步
7. **可视化界面**：美观的Web界面，实时显示系统状态

## 7.2 收获与体会

通过本次课程设计，深入理解了：
- 文件系统的组织结构和iNode机制
- 磁盘空间管理的位图法
- 缓冲区管理和页面置换算法
- 进程调度的时间片轮转算法
- 进程间通信的共享内存机制
- 条件变量在同步中的应用

## 7.3 展望

未来可以在以下方面进行改进：
- 增加多用户支持和权限管理
- 支持更多文件系统特性（符号链接、硬链接等）
- 优化缓冲区管理策略
- 增加更多调度算法选择
- 支持网络文件系统功能

---

# 参考文献

[1] 汤小丹, 梁红兵, 哲凤屏, 汤子瀛. 计算机操作系统（第四版）[M]. 西安: 西安电子科技大学出版社, 2014.

[2] Abraham Silberschatz, Peter B. Galvin, Greg Gagne. Operating System Concepts (10th Edition)[M]. Wiley, 2018.

[3] Flask官方文档. https://flask.palletsprojects.com/

[4] React官方文档. https://react.dev/

[5] Python Threading文档. https://docs.python.org/3/library/threading.html

---

# 附录

## A. 项目结构

```
OS/
├── backend/                    # Python后端
│   ├── app.py                 # Flask主应用
│   ├── config.py              # 配置文件
│   └── core/                  # 核心模块
│       ├── disk.py            # 虚拟磁盘
│       ├── filesystem.py      # 文件系统
│       ├── buffer.py          # 缓冲区管理
│       ├── process.py         # 进程管理
│       ├── scheduler.py       # 调度器
│       └── ipc.py             # IPC通信
├── frontend/                   # React前端
│   └── src/
│       ├── App.tsx            # 主应用
│       ├── components/        # UI组件
│       └── services/          # API服务
└── docs/                       # 文档
```

## B. 配置参数

| 参数 | 值 | 说明 |
|------|----|----- |
| BLOCK_SIZE | 64 | 块大小(字节) |
| BLOCK_COUNT | 1024 | 块数量 |
| BUFFER_PAGE_COUNT | 16 | 缓冲页数量 |
| TIME_QUANTUM | 100 | 时间片(毫秒) |
| IO_DELAY | 0.3 | I/O延时(秒) |
| PAGE_SWAP_DELAY | 0.5 | 置换延时(秒) |

